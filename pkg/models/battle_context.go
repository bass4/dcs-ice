package models

import (
    "strconv"
    "strings"
)

// BattleContext holds the state and facts for rule evaluation
type BattleContext struct {
    facts      map[string][]Fact  // Map of fact type to slice of facts
    factValues map[string]string  // Simple key-value store for current state
    actions    []Action           // Actions generated by rules
}

// NewBattleContext creates a new battle context from a list of facts
func NewBattleContext(facts []Fact) *BattleContext {
    bc := &BattleContext{
        facts:      make(map[string][]Fact),
        factValues: make(map[string]string),
        actions:    make([]Action, 0),
    }
    
    // Organize facts by type
    for _, fact := range facts {
        // Store in the facts map by type
        bc.facts[fact.Type] = append(bc.facts[fact.Type], fact)
        
        // Store as current value (last one wins for duplicates)
        bc.factValues[fact.Type] = fact.Value
        
        // Store all fields as key-value pairs
        if fact.Zone != "" {
            bc.factValues[fact.Type + "_zone"] = fact.Zone
        }
        if fact.UnitType != "" {
            bc.factValues[fact.Type + "_unittype"] = fact.UnitType
        }
        if fact.GroupName != "" {
            bc.factValues[fact.Type + "_groupname"] = fact.GroupName
        }
        if fact.Count != "" {
            bc.factValues[fact.Type + "_count"] = fact.Count
        }
    }
    
    return bc
}

// GetValue returns the value for a fact type
func (bc *BattleContext) GetValue(factType string) string {
    return bc.factValues[factType]
}

// SetValue sets the value for a fact type
func (bc *BattleContext) SetValue(factType, value string) {
    bc.factValues[factType] = value
}

// HasFact checks if a fact of the given type exists
func (bc *BattleContext) HasFact(factType string) bool {
    value, exists := bc.factValues[factType]
    return exists && value != ""
}

// GetAttribute returns an attribute for a fact type
func (bc *BattleContext) GetAttribute(factType, attribute string) string {
    return bc.factValues[factType + "_" + attribute]
}

// ClearFact removes a fact from consideration
func (bc *BattleContext) ClearFact(factType string) {
    bc.factValues[factType] = ""
    // Also clear related attributes
    for key := range bc.factValues {
        if strings.HasPrefix(key, factType + "_") {
            bc.factValues[key] = ""
        }
    }
}

// CreateAction creates a generic action
func (bc *BattleContext) CreateAction(actionType, subType string, attributes map[string]string) {
    action := Action{
        Type:    actionType,
        SubType: subType,
    }
    
    // Set attributes
    for key, value := range attributes {
        switch key {
        case "zone":
            action.Zone = value
        case "unitType":
            action.UnitType = value
        case "count":
            action.Count = value
        case "message":
            action.Message = value
        case "level":
            action.Level = value
        case "groupName":
            action.GroupName = value
        }
    }
    
    bc.actions = append(bc.actions, action)
}

// GetActions returns all actions created during rule evaluation
func (bc *BattleContext) GetActions() []Action {
    return bc.actions
}

// Compatibility methods for rules

// GetEvent returns the current event
func (bc *BattleContext) GetEvent() string {
    return bc.GetValue("event")
}

// SetEvent sets the current event
func (bc *BattleContext) SetEvent(value string) {
    bc.SetValue("event", value)
}

// GetZone returns the zone associated with the current event
func (bc *BattleContext) GetZone() string {
    return bc.GetAttribute("event", "zone")
}

// GetAlertLevel returns the current alert level
func (bc *BattleContext) GetAlertLevel() string {
    return bc.GetValue("alert_level")
}

// SetAlertLevel sets the current alert level
func (bc *BattleContext) SetAlertLevel(value string) {
    bc.SetValue("alert_level", value)
}

// GetUnitCount returns the unit count as an integer
func (bc *BattleContext) GetUnitCount() int {
    countStr := bc.GetAttribute("event", "count")
    if countStr == "" {
        return 0
    }
    
    count, err := strconv.Atoi(countStr)
    if err != nil {
        return 0
    }
    
    return count
}

// CreateSpawnAction creates a spawn action (compatibility method)
func (bc *BattleContext) CreateSpawnAction(actionType, zone, unitType, count string) {
    bc.CreateAction("spawn", actionType, map[string]string{
        "zone":     zone,
        "unitType": unitType,
        "count":    count,
    })
}

// CreateAlertAction creates an alert action (compatibility method)
func (bc *BattleContext) CreateAlertAction(actionType, level, message string) {
    bc.CreateAction("alert", actionType, map[string]string{
        "level":   level,
        "message": message,
    })
}

// For chain rules support
func (bc *BattleContext) AddMatchedRule(ruleName string) {
    bc.factValues["matched_rule_"+ruleName] = "true"
}

func (bc *BattleContext) HasMatchedRule(ruleName string) bool {
    value, exists := bc.factValues["matched_rule_"+ruleName]
    return exists && value == "true"
}
